import { NextResponse } from 'next/server';
import { insert, executeQuery, update } from '@/lib/db';
import fs from 'fs';
import path from 'path';
import { randomUUID } from 'crypto';

// D√©sactiver le body parser pour les uploads multipart/form-data
export const config = {
  api: {
    bodyParser: false,
  },
};

// Fonction pour assurer que les r√©pertoires d'upload existent
function ensureUploadDirectories() {
  const publicDir = path.join(process.cwd(), 'public');
  const uploadsDir = path.join(publicDir, 'uploads');
  const placesDir = path.join(uploadsDir, 'places');
  
  try {
    // Cr√©er les r√©pertoires s'ils n'existent pas
    if (!fs.existsSync(publicDir)) {
      console.log('Cr√©ation du r√©pertoire public');
      fs.mkdirSync(publicDir);
    }
    
    if (!fs.existsSync(uploadsDir)) {
      console.log('Cr√©ation du r√©pertoire uploads');
      fs.mkdirSync(uploadsDir);
    }
    
    if (!fs.existsSync(placesDir)) {
      console.log('Cr√©ation du r√©pertoire places');
      fs.mkdirSync(placesDir);
    }
    
    // Tester l'√©criture dans le r√©pertoire
    const testFile = path.join(placesDir, 'test-access.txt');
    fs.writeFileSync(testFile, 'Test write access');
    fs.unlinkSync(testFile);
    
    return { success: true, directories: { publicDir, uploadsDir, placesDir } };
  } catch (error) {
    console.error('Erreur lors de la cr√©ation des r√©pertoires:', error);
    return { success: false, error: error.message };
  }
}

async function readFormData(request) {
  try {
    const formData = await request.formData();
    return { success: true, formData };
  } catch (error) {
    console.error('Erreur lors de la lecture du formData:', error);
    return { success: false, error: error.message };
  }
}

// Fonction pour analyser le formulaire multipart
async function parseForm(request) {
  try {
    console.log('API: D√©but du parsing du formulaire multipart');
    
    // R√©cup√©rer les r√©pertoires d'upload
    const dirResult = ensureUploadDirectories();
    if (!dirResult.success) {
      throw new Error(`Probl√®me avec les r√©pertoires d'upload: ${dirResult.error}`);
    }
    
    // Lire les donn√©es du formulaire
    const formData = await request.formData();
    console.log('API: FormData re√ßu avec les champs:', Array.from(formData.keys()));
    
    // Convertir FormData en objet structur√©
    const fields = {};
    const files = {};
    
    for (const [key, value] of formData.entries()) {
      if (value instanceof File) {
        files[key] = value;
        console.log(`API: Fichier re√ßu pour le champ '${key}': ${value.name}, ${value.size} octets`);
      } else {
        // Pour les champs textuels, les organiser en tableaux (comme le fait formidable)
        if (!fields[key]) {
          fields[key] = [];
        }
        fields[key].push(value);
        
        // Ne pas afficher les valeurs potentiellement sensibles dans les logs
        console.log(`API: Champ '${key}' re√ßu`);
      }
    }
    
    return { fields, files };
  } catch (error) {
    console.error('API: Erreur lors du parsing du formulaire multipart:', error);
    throw error;
  }
}

// Fonction pour valider le type de fichier
function validateFileType(file) {
  if (!file || !(file instanceof File)) {
    return false;
  }
  
  const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
  return allowedTypes.includes(file.type);
}

// Fonction pour d√©placer un fichier upload√©
async function moveUploadedFile(file, prefix, id) {
  try {
    if (!file || !(file instanceof File)) {
      throw new Error('Fichier invalide');
    }
    
    console.log(`API: Traitement du fichier ${file.name} (${file.size} octets)`);
    
    // V√©rifier que les r√©pertoires existent
    const dirResult = ensureUploadDirectories();
    if (!dirResult.success) {
      throw new Error(`Probl√®me avec les r√©pertoires d'upload: ${dirResult.error}`);
    }
    
    // G√©n√©rer un nom de fichier unique
    const fileExtension = file.name.split('.').pop().toLowerCase();
    const uniqueId = randomUUID();
    const timestamp = Date.now();
    const newFilename = `${prefix}_${id}_${timestamp}_${uniqueId.slice(0, 8)}.${fileExtension}`;
    
    const placesDir = path.join(process.cwd(), 'public', 'uploads', 'places');
    const imagePath = path.join(placesDir, newFilename);
    console.log(`API: Chemin complet du fichier: ${imagePath}`);
    
    try {
      // Convertir le fichier en buffer (op√©ration asynchrone)
      const arrayBuffer = await file.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      
      // V√©rifier que le r√©pertoire de destination existe
      if (!fs.existsSync(placesDir)) {
        console.log(`API: Cr√©ation du r√©pertoire manquant: ${placesDir}`);
        fs.mkdirSync(placesDir, { recursive: true });
      }
      
      // √âcrire le fichier
      fs.writeFileSync(imagePath, buffer);
      console.log(`API: Fichier √©crit avec succ√®s: ${newFilename}`);
      
      // V√©rifier que le fichier a bien √©t√© √©crit
      if (!fs.existsSync(imagePath)) {
        throw new Error('Le fichier n\'a pas √©t√© correctement √©crit sur le disque');
      }
      
      // Retourner le chemin relatif pour l'URL
      return `/uploads/places/${newFilename}`;
    } catch (fileError) {
      console.error(`API: Erreur lors de l'√©criture du fichier:`, fileError);
      throw new Error(`Erreur lors de l'√©criture du fichier: ${fileError.message}`);
    }
  } catch (error) {
    console.error('API: Erreur lors du d√©placement du fichier:', error);
    throw error;
  }
}

export async function POST(request) {
  console.log('üì• Requ√™te re√ßue sur /api/places/upload');
  
  try {
    // 1. S'assurer que les r√©pertoires existent
    const dirResult = ensureUploadDirectories();
    if (!dirResult.success) {
      return NextResponse.json({ 
        success: false, 
        error: `Probl√®me avec les r√©pertoires d'upload: ${dirResult.error}` 
      }, { status: 500 });
    }
    
    // 2. Lire les donn√©es du formulaire
    const formDataResult = await readFormData(request);
    if (!formDataResult.success) {
      return NextResponse.json({ 
        success: false, 
        error: `Probl√®me avec les donn√©es du formulaire: ${formDataResult.error}` 
      }, { status: 400 });
    }
    
    const formData = formDataResult.formData;
    console.log('üìã FormData re√ßu avec les champs:', Array.from(formData.keys()));
    
    // 3. R√©cup√©rer les champs du formulaire
    const name = formData.get('name');
    const slug = formData.get('slug');
    const city_id = formData.get('city_id');
    const category_id = formData.get('category_id');
    const description = formData.get('description');
    const location = formData.get('location');
    const imageFile = formData.get('image');
    
    console.log('üìù Champs extraits du formulaire:', { 
      name, 
      slug, 
      city_id, 
      category_id, 
      description_length: description?.length,
      location,
      has_location_field: formData.has('location'),
      imageFile_name: imageFile?.name
    });
    
    // 4. Valider les champs obligatoires
    if (!name || !slug || !city_id || !category_id) {
      console.error('‚ùå Champs obligatoires manquants');
      return NextResponse.json({
        success: false,
        error: 'Champs obligatoires manquants (name, slug, city_id, category_id)',
        received: { name, slug, city_id, category_id }
      }, { status: 400 });
    }
    
    // 5. V√©rifier si la ville existe
    const cityResult = await executeQuery('SELECT id FROM cities WHERE id = ?', [city_id]);
    if (!cityResult.length) {
      console.error(`‚ùå Ville non trouv√©e: ${city_id}`);
      return NextResponse.json({
        success: false,
        error: `La ville avec l'ID ${city_id} n'existe pas`
      }, { status: 400 });
    }
    
    // 6. V√©rifier si la cat√©gorie existe
    const categoryResult = await executeQuery('SELECT id FROM categories WHERE id = ?', [category_id]);
    if (!categoryResult.length) {
      console.error(`‚ùå Cat√©gorie non trouv√©e: ${category_id}`);
      return NextResponse.json({
        success: false,
        error: `La cat√©gorie avec l'ID ${category_id} n'existe pas`
      }, { status: 400 });
    }
    
    // 7. V√©rifier que le slug est unique pour cette ville
    const slugCheckResult = await executeQuery(
      'SELECT id FROM places WHERE slug = ? AND city_id = ?', 
      [slug, city_id]
    );
    
    if (slugCheckResult.length > 0) {
      console.error(`‚ùå Un lieu avec le slug "${slug}" existe d√©j√† pour cette ville`);
      return NextResponse.json({
        success: false,
        error: `Un lieu avec le slug "${slug}" existe d√©j√† pour cette ville`
      }, { status: 400 });
    }
    
    // 8. Traiter l'image si pr√©sente
    let image_path = null;
    
    if (imageFile && imageFile instanceof File) {
      console.log('üñºÔ∏è Traitement de l\'image:', imageFile.name, imageFile.type, `${Math.round(imageFile.size / 1024)} KB`);
      
      // G√©n√©rer un nom de fichier unique
      const fileExtension = imageFile.name.split('.').pop().toLowerCase();
      const allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];
      
      if (!allowedExtensions.includes(fileExtension)) {
        console.error(`‚ùå Type de fichier non autoris√©: ${fileExtension}`);
        return NextResponse.json({
          success: false,
          error: `Type de fichier non autoris√©. Extensions accept√©es: ${allowedExtensions.join(', ')}`
        }, { status: 400 });
      }
      
      // Cr√©er un nom de fichier unique
      const uniqueId = randomUUID();
      const timestamp = Date.now();
      const newFilename = `img_${timestamp}_${uniqueId.slice(0, 8)}.${fileExtension}`;
      const imagePath = path.join(process.cwd(), 'public', 'uploads', 'places', newFilename);
      
      // Convertir le fichier en buffer
      const buffer = Buffer.from(await imageFile.arrayBuffer());
      
      // √âcrire le fichier
      fs.writeFileSync(imagePath, buffer);
      console.log(`‚úÖ Image sauvegard√©e: ${imagePath}`);
      
      // D√©finir le chemin relatif pour la base de donn√©es
      image_path = `/uploads/places/${newFilename}`;
    } else {
      console.log('‚ö†Ô∏è Aucune image fournie ou format invalide');
    }
    
    // 9. Pr√©parer les donn√©es pour l'insertion
    const placeData = {
      name,
      slug,
      city_id,
      category_id,
      description: description || null,
      location: location || null,
      image_path: image_path,
      status: 'published',
      created_at: new Date().toISOString().slice(0, 19).replace('T', ' ')
    };
    
    console.log('üìä Donn√©es √† ins√©rer dans la table places:', placeData);
    
    // 10. Ins√©rer le lieu dans la base de donn√©es
    try {
      const result = await insert('places', placeData);
      console.log('‚ú® Lieu ajout√© avec succ√®s, ID:', result.lastID);
      
      return NextResponse.json({
        success: true,
        message: 'Lieu ajout√© avec succ√®s',
        place: {
          id: result.lastID,
          ...placeData
        }
      });
    } catch (dbError) {
      console.error('‚ùå Erreur lors de l\'insertion dans la base de donn√©es:', dbError);
      
      // Si une image a √©t√© sauvegard√©e, la supprimer en cas d'√©chec
      if (image_path) {
        try {
          const fullPath = path.join(process.cwd(), 'public', image_path);
          fs.unlinkSync(fullPath);
          console.log(`üóëÔ∏è Image supprim√©e suite √† l'√©chec de l'insertion: ${fullPath}`);
        } catch (cleanupError) {
          console.error('‚ö†Ô∏è Erreur lors de la suppression de l\'image:', cleanupError);
        }
      }
      
      return NextResponse.json({
        success: false,
        error: `Erreur lors de l'insertion dans la base de donn√©es: ${dbError.message}`
      }, { status: 500 });
    }
  } catch (error) {
    console.error('üí• Erreur g√©n√©rale lors du traitement de la requ√™te:', error);
    return NextResponse.json({
      success: false,
      error: `Erreur lors du traitement de la requ√™te: ${error.message}`
    }, { status: 500 });
  }
}

// PUT /api/places/upload - Endpoint pour mettre √† jour un lieu avec une image
export async function PUT(request) {
  try {
    console.log('API: R√©ception d\'une requ√™te de mise √† jour avec image pour un lieu');
    
    // Analyser le formulaire multipart
    const { fields, files } = await parseForm(request);
    console.log('API: Formulaire pars√© avec champs:', Object.keys(fields));
    
    // Extraire les champs du formulaire
    const id = fields.id?.[0];
    const name = fields.name?.[0] || '';
    const slug = fields.slug?.[0] || '';
    const description = fields.description?.[0] || '';
    const location = fields.location?.[0] || '';
    
    // Conserver les informations de cat√©gorie et ville
    const category_id = fields.category_id?.[0];
    const city_id = fields.city_id?.[0];
    
    // V√©rifier que l'ID est pr√©sent
    if (!id) {
      console.error('API: ID manquant dans la requ√™te PUT');
      return NextResponse.json(
        { error: 'L\'identifiant du lieu est requis' },
        { status: 400 }
      );
    }
    
    // V√©rifier que le lieu existe
    const placeQuery = 'SELECT * FROM places WHERE id = ?';
    console.log(`API: Recherche du lieu avec l'ID: ${id}`);
    const places = await executeQuery(placeQuery, [id]);
    
    if (places.length === 0) {
      console.error(`API: Lieu avec ID ${id} non trouv√© dans la base de donn√©es`);
      return NextResponse.json(
        { error: 'Le lieu sp√©cifi√© n\'existe pas' },
        { status: 404 }
      );
    }
    
    const existingPlace = places[0];
    console.log(`API: Lieu trouv√©: ${existingPlace.name} (ID: ${existingPlace.id})`);
    
    // V√©rifier et traiter l'image
    const imageFile = files.image;
    let imagePath = existingPlace.image_path;
    
    if (imageFile) {
      console.log(`API: Traitement de l'image: ${imageFile.name}, taille: ${imageFile.size} octets`);
      
      // Valider le type de fichier
      if (!validateFileType(imageFile)) {
        console.error(`API: Type de fichier non autoris√©: ${imageFile.type}`);
        return NextResponse.json(
          { error: 'Type de fichier non autoris√©. Utilisez JPG, JPEG, PNG ou GIF.' },
          { status: 400 }
        );
      }
      
      // D√©placer la nouvelle image
      try {
        imagePath = await moveUploadedFile(imageFile, 'place', id);
        console.log('API: Nouvelle image d√©plac√©e vers:', imagePath);
      } catch (uploadError) {
        console.error('API: Erreur lors du d√©placement de l\'image:', uploadError);
        return NextResponse.json(
          { error: `Erreur lors du traitement de l'image: ${uploadError.message}` },
          { status: 500 }
        );
      }
    } else {
      console.log('API: Aucune nouvelle image fournie, conservation de l\'image existante');
    }
    
    // Pr√©parer les donn√©es pour la mise √† jour
    const placeData = {
      name: name || existingPlace.name,
      slug: slug || existingPlace.slug,
      description: description !== undefined ? description : existingPlace.description,
      location: location || existingPlace.location,
      image_path: imagePath
    };
    
    // Conserver les champs category_id et city_id s'ils sont pr√©sents dans les donn√©es existantes
    if (category_id) {
      placeData.category_id = category_id;
    } else if (existingPlace.category_id) {
      placeData.category_id = existingPlace.category_id;
    }
    
    if (city_id) {
      placeData.city_id = city_id;
    } else if (existingPlace.city_id) {
      placeData.city_id = existingPlace.city_id;
    }
    
    // Ajouter la date de mise √† jour
    placeData.updated_at = new Date().toISOString().slice(0, 19).replace('T', ' ');
    
    console.log('API: Donn√©es pr√©par√©es pour mise √† jour du lieu:', placeData);
    
    // Mettre √† jour le lieu dans la base de donn√©es
    try {
      console.log(`API: Tentative de mise √† jour du lieu ID ${id} dans la table 'places'`);
      const updatedPlace = await update('places', id, placeData);
      console.log('API: Lieu mis √† jour avec succ√®s, ID:', id);
      
      return NextResponse.json(updatedPlace);
    } catch (updateError) {
      console.error('API: Erreur sp√©cifique de mise √† jour de lieu:', updateError);
      return NextResponse.json(
        { error: `Erreur lors de la mise √† jour du lieu: ${updateError.message}` },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('API: Erreur lors de la mise √† jour du lieu avec image:', error);
    return NextResponse.json(
      { error: `Erreur lors de la mise √† jour du lieu: ${error.message}` },
      { status: 500 }
    );
  }
} 